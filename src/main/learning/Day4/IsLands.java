package learning.Day4;

/**
 * @description: 求只有1 0的数组中有几个岛
 * 1 0 0 0 1
 * 1 0 1 0 1       如左，共有4个岛，分别是左上，右上，正中间，右下
 * 0 0 0 1 0
 * <p>
 * 解决办法1：使用递归，基于的是单CPU。两个for循环遍历，从左上开始一直到右下，当遇到1就将这个1的上下左右如果为1全部变成2。右边同理就不画了
 * 2 0 0 0 2
 * 2 0 2 0 2      就像这样：使用的方式是两个for，for中有个方法如果碰到1就递归寻找上下左右找到1并将其“感染”成2
 * 0 0 0 2 0
 * <p>
 * 解决方法2：对于多CPU就能，使用并查集，将上面矩阵分成n块（为了方便理解，下面就分成2块），
 * 0 1 1 0
 * 1 1 1 0   改变数组如下，以2 3列之间为中心分割。分割后左边共有1个岛，右边有2个岛，
 * 0 0 0 1
 * 一样两个for循环，
 * 左边开始遍历到[0,1]发现为1，遍历其下[0,2][1,1]都为1，就将这三个位置“指向”（注意是指向不是改变）A，
 * 右边开始遍历到[0,0]之后向左向右向上向下发现和[1,0]是连在一起的，就将[0,0][1,0]都“指向”B。同样的[1,2]指向“C”
 * 这时候全部查出来，左边1个岛，右边两个岛，（总共三个岛）开始使用并查集合并。因为左边的[0,1]和右边的[0,0]相邻，然后就判断是否来自同一个节点（并查集方法），
 * 如果不来自一个节点就使用并查集将两个union一起，因为左边一片都指向A，右边[0,0][0,1]都指向B，最后B会被统一连到A。（总共的3个岛 减1 ！！！）
 * 当找到左边[1,1]和右边[1,0] 发现相邻时，查找是否来自一个节点，发现是来自一个节点（union之后）。就当无事发生。
 * 最后结算就是2个岛
 * @Time: 2019/11/8 22:36
 */
public class IsLands {
    /**
     * 仅使用第一种方法，第二种存在理论中
     *
     * @param m
     * @return
     */
    public static int countIsLands(int[][] m) {
        if (m == null || m[0] == null)
            return 0;
        int N = m.length;   //长，几个数组
        int M = m[0].length; //宽，数组几个数
        int landNum = 0;  //岛数量
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < M; j++) {
                if (m[i][j] == 1) {  //是否为1，因为感染会变成2,
                    landNum++;
                    infect(m, i, j, N, M);  //感染函数
                }
            }
        }
        return landNum;
    }

    /**
     * 感染函数
     *
     * @param m    二维数组
     * @param i    m[i][j]  为1
     * @param j    m[i][j]  为1
     * @param Long 二维数组最大长度
     * @param wide 一维数组最大长度
     */
    private static void infect(int[][] m, int i, int j, int Long, int wide) {
        //前四个保证数组不越界。最后一个保证遇到非1停止
        if (i < 0 || i >= Long || j < 0 || j >= wide || m[i][j] != 1)
            return;
        m[i][j] = 2;
        infect(m, i-1, j, Long, wide);  //向上，注意这里不能使用i--，因为下面还需要使用i，同理++，j--j++也不行！！！
        infect(m, i+1, j, Long, wide);  //向下
        infect(m, i, j+1, Long, wide);  //向右
        infect(m, i, j-1, Long, wide);  //向左
    }

    public static void main(String[] args) {
        int[][] m1 = {
                {0, 0, 0, 0, 0, 0, 0, 0, 0},
                {0, 1, 1, 1, 0, 1, 1, 1, 0},
                {0, 1, 1, 1, 0, 0, 0, 1, 0},
                {0, 1, 1, 0, 0, 0, 0, 0, 0},
                {0, 0, 0, 0, 0, 1, 1, 0, 0},
                {0, 0, 0, 0, 1, 1, 1, 0, 0},
                {0, 0, 0, 0, 0, 0, 0, 0, 0},};
        System.out.println(countIsLands(m1));

        int[][] m2 = {{0, 0, 0, 0, 0, 0, 0, 0, 0},
                {0, 1, 1, 1, 1, 1, 1, 1, 0},
                {0, 1, 1, 1, 0, 0, 0, 1, 0},
                {0, 1, 1, 0, 0, 0, 1, 1, 0},
                {0, 0, 0, 0, 0, 1, 1, 0, 0},
                {0, 0, 0, 0, 1, 1, 1, 0, 0},
                {0, 0, 0, 0, 0, 0, 0, 0, 0},};
        System.out.println(countIsLands(m2));

    }
}
